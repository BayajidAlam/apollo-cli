import chalk from 'chalk';
import ejs from 'ejs';
import fs from 'fs-extra';
import path from 'path';

/**
 * Renders an EJS template and writes the output to the target path.
 */
export async function renderTemplate(
  templateName: string,
  targetPath: string,
  data: Record<string, any> = {}
) {
  try {
    const templateDir = path.resolve(__dirname, '../templates');
    let templatePath = path.join(templateDir, templateName);

    // Fallback for development (src/templates)
    if (!fs.existsSync(templatePath)) {
      templatePath = path.resolve(
        __dirname,
        '../../src/templates',
        templateName
      );
    }

    if (!fs.existsSync(templatePath)) {
      console.error(chalk.red(`❌ Template not found at: ${templatePath}`));
      return;
    }

    const templateContent = await fs.readFile(templatePath, 'utf-8');
    const renderedContent = ejs.render(templateContent, data);

    await fs.ensureDir(path.dirname(targetPath));
    await fs.writeFile(targetPath, renderedContent);

    console.log(
      chalk.green(`✓ Created: ${path.relative(process.cwd(), targetPath)}`)
    );
  } catch (error) {
    console.error(chalk.red('❌ Error generating file:'), error);
    process.exit(1);
  }
}

/**
 * Generates the package.json file for the new project.
 */
export async function writePackageJson(
  projectRoot: string,
  projectName: string,
  dependencies: any,
  devDependencies: any
) {
  const packageJson = {
    name: projectName,
    version: '1.0.0',
    description: 'Backend project generated by Apollo Gears CLI',
    main: 'dist/server.js',
    scripts: {
      start: 'node dist/server.js',
      dev: 'ts-node-dev --respawn --transpile-only src/server.ts',
      build: 'tsc',
      lint: 'eslint src/**/*.ts',
      'lint:fix': 'eslint src/**/*.ts --fix',
      format: 'prettier --write .',
    },
    keywords: ['express', 'prisma', 'typescript', 'apollo-gears'],
    author: '',
    license: 'ISC',
    dependencies,
    devDependencies,
  };
  await fs.writeJson(path.join(projectRoot, 'package.json'), packageJson, {
    spaces: 2,
  });
}

/**
 * Generates the tsconfig.json file with TypeScript configuration.
 */
export async function writeTsConfig(projectRoot: string) {
  const tsconfig = {
    compilerOptions: {
      target: 'ES2021',
      module: 'commonjs',
      moduleResolution: 'node',
      outDir: './dist',
      rootDir: './src',
      strict: true,
      esModuleInterop: true,
      skipLibCheck: true,
      forceConsistentCasingInFileNames: true,
    },
    include: ['src/**/*'],
    exclude: ['node_modules', 'dist', 'generated/prisma'],
  };
  await fs.writeJson(path.join(projectRoot, 'tsconfig.json'), tsconfig, {
    spaces: 2,
  });
}

export async function writeServerFile(projectRoot: string) {
  await renderTemplate(
    'init/server.ejs',
    path.join(projectRoot, 'src/server.ts'),
    { port: 5000 }
  );
}

export async function writeAppFile(projectRoot: string) {
  await renderTemplate('init/app.ejs', path.join(projectRoot, 'src/app.ts'));
}

export async function writeConfigFile(projectRoot: string) {
  await renderTemplate(
    'init/config.ejs',
    path.join(projectRoot, 'src/config/index.ts')
  );
}

export async function writeEnvFile(projectRoot: string) {
  await renderTemplate('init/env.ejs', path.join(projectRoot, '.env'));
}

export async function writePrismaFile(projectRoot: string) {
  await renderTemplate(
    'init/prisma.ejs',
    path.join(projectRoot, 'src/lib/prisma.ts')
  );
}

export async function writePrismaSchema(projectRoot: string) {
  await renderTemplate(
    'init/prisma-schema.ejs',
    path.join(projectRoot, 'prisma/schema.prisma')
  );
}

export async function writeGitIgnore(projectRoot: string) {
  await renderTemplate(
    'init/gitignore.ejs',
    path.join(projectRoot, '.gitignore')
  );
}
